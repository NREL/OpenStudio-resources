require 'openstudio' unless defined?(OpenStudio)

require 'etc'
require 'fileutils'
require 'json'
require 'erb'
require 'timeout'
require 'open3'

require 'etc'

require 'minitest/autorun'
begin
  require "minitest/reporters"
  require "minitest/reporters/default_reporter"
  reporter = Minitest::Reporters::DefaultReporter.new
  reporter.start # had to call start manually otherwise was failing when trying to report elapsed time when run in CLI
  Minitest::Reporters.use! reporter
rescue LoadError
  puts "Minitest Reporters not installed"
end

# Backward compat
Minitest::Test = MiniTest::Unit::TestCase unless defined?(Minitest::Test)



# Environment variables
if ENV['N'].nil?
  # Number of parallel runs caps to nproc - 1
  ENV['N'] = [1, Etc.nprocessors - 1].max.to_s
end

# Variables to store the environment variables
$Custom_tag=''
$Save_idf=false

# Don't rerun test if there is already an OSW that shows success if the test/
# directory
$DoNotReRunIfSuccess=false

if ENV['DONOTRERUNIFSUCCESS'].to_s.downcase == "true"
  $DoNotReRunIfSuccess=true
end


# config stuff
$OpenstudioCli = OpenStudio::getOpenStudioCLI
$RootDir = File.absolute_path(File.dirname(__FILE__))
$OswFile = File.join($RootDir, 'test.osw')
$ModelDir = File.join($RootDir, 'model/simulationtests/')
$IntersectDir = File.join($RootDir, 'model/intersectiontests/')
$IntersectFile = File.join($RootDir, 'intersect.rb.erb')
$TestDir = File.join($RootDir, 'testruns')
$SddSimDir = File.join($RootDir, 'model/sddtests/')
# $TestDirSddFT = File.join($RootDir, 'testruns/SddForwardTranslator/')
# if File.exists?($TestDirSddFT)
#   FileUtils.mkdir_p($TestDirSddFT)
# end
#
# Temporary place to store the OSMs generated by Reverse Translator before
# they get simulated through OpenStudio/EnergyPlus
$TestDirSddRT = File.join($RootDir, 'testruns/SddReverseTranslator/')
if File.exists?($TestDirSddRT)
  FileUtils.mkdir_p($TestDirSddRT)
end

$SdkVersion = OpenStudio.openStudioVersion
$SdkLongVersion = OpenStudio::openStudioLongVersion
$Build_Sha = $SdkLongVersion.split('.')[-1]


puts "Running for OpenStudio #{$SdkLongVersion}"

# Where to cp the out.osw for regression
# Depends on whether you are in a docker env or not
proc_file = '/proc/1/cgroup'
is_docker = File.file?(proc_file) && (File.readlines(proc_file).grep(/docker/).size > 0)
if is_docker
  # Mounted directory is at /root/test
  $OutOSWDir = File.join(ENV['HOME'], 'test')
else
  # Directly in here
  $OutOSWDir = File.join($RootDir, 'test')

  # if the user didn't supply env CUSTOMTAG=whatever,
  # we ask him to optionally supply a tag
=begin
     n
     n  if ENV["CUSTOMTAG"].nil?
     n    # Ask user if he wants to append a custom tag to the result out.osw
     n    # We don't do it in docker so it can just run without user input
     n    prompt = ("If you want to append a custom tag to the result out.osw(s) (eg: 'Windows_run3')\n"\
     n              "enter it now, or type 'SHA' to append the build sha (#{$Build_Sha}),\n"\
     n              "or leave empty if not desired\n> ")
     n    ENV["CUSTOMTAG"] = [(print prompt), STDIN.gets.chomp][1]
     n  end
=end

end

# Output the SDDFT'ed XMLs in the same folder as model/rb out.OSW
$TestDirSddFT = $OutOSWDir

if !ENV["CUSTOMTAG"].nil?
  $Custom_tag = ENV['CUSTOMTAG']
  # Debug
  # puts "Setting custom tag to #{$Custom_tag}"
end

if not $Custom_tag.empty?
  if $Custom_tag.downcase == 'sha'
    $Custom_tag = $Build_Sha
  end
  $Custom_tag = "_#{$Custom_tag}"
  puts "Custom tag will be appended, files will be named like 'testname_#{$SdkVersion}_out#{$Custom_tag}.osw'\n"
end

# If an ENV variable was given with a value of "True" (case insensitive)
if ENV["SAVE_IDF"].to_s.downcase == "true"
  $Save_idf=true
  puts "Will save the IDF files in the test/ directory"
end

$:.unshift($ModelDir)
ENV['RUBYLIB'] = $ModelDir
ENV['RUBYPATH'] = $ModelDir


# bundle install a gemfile identified by directory name inside of 'gemfiles'
# returns full directory name gemfile_dir
# gemfile at gemfile_dir + 'Gemfile', bundle at gemfile_dir + 'gems'
def bundle_install(gemfile_dirname, force_install)

  original_dir = Dir.pwd
  gemfile_dir = File.join($RootDir, 'gemfiles', gemfile_dirname)
  fail "Gemfile dir '#{gemfile_dir}' does not exist" if !File.exists?(gemfile_dir)

  Dir.chdir(gemfile_dir)

  if force_install
    FileUtils.rm_rf('Gemfile.lock') if File.exists?('Gemfile.lock')
    FileUtils.rm_rf('./gems') if File.exists?('./gems')
    FileUtils.rm_rf('./bundle') if File.exists?('./bundle')
  end

  assert(system('bundle install --path ./gems'))

  Dir.chdir(gemfile_dir)

  assert(system('bundle lock --add_platform ruby'))

  return gemfile_dir

ensure
  Dir.chdir(original_dir)
end

# run a command in directory dir, throws exception on timeout or exit status != 0, always returns to initial directory
def run_command(command, dir, timeout)
  begin
    pwd = Dir.pwd
    Dir.chdir(dir)

    result = nil
    Open3.popen3(command) do |i,o,e,w|
      out = ""
      begin
        Timeout.timeout(timeout) do
          # process output of the process. it will produce EOF when done.
          until o.eof? do
            out += o.readpartial(100)
          end
          until e.eof? do
            out += e.readpartial(100)
          end
        end

        result = w.value.exitstatus
        if result != 0
          Dir.chdir(pwd)
          fail "Exit code #{result}:\n#{out}"
        end

      rescue Timeout::Error
        # Process.kill does not work on Windows
        #https://blog.simplificator.com/2016/01/18/how-to-kill-processes-on-windows-using-ruby/
        if Gem.win_platform?
          system("taskkill /f /pid #{w.pid}")
        else
          Process.kill("KILL", w.pid)
        end
        Dir.chdir(pwd)
        fail "Timeout #{timeout}:\n#{out}"
      end
    end
  ensure
    Dir.chdir(pwd)
  end
end

# Helper function to post-process the out.osw and save it in test/ with
# the right naming pattern
# It also asserts whether the run was successful
#
# Cleaning includes removing timestamp and deleting :eplusout_err key if
# bigger than 100 KiB
# @param out_osw [String]: full path to the out_osw
# @param cp_out_osw [String]: path to where the sanitized OSW should be output
#
# @return result_osw [Hash]: the sanitized result_osw should you need to do
# more stuff with it
def postprocess_out_osw_and_copy(out_osw, cp_out_osw)

  fail "Cannot find file #{out_osw}" if !File.exists?(out_osw)

  result_osw = nil
  File.open(out_osw, 'r') do |f|
    result_osw = JSON::parse(f.read, :symbolize_names=>true)
  end

  if !result_osw.nil?
    # FileUtils.cp(out_osw, cp_out_osw)

    # Instead of just copying, we clean up the osw then export that to a file
    # Remove timestamps and hash
    if result_osw.keys.include?(:eplusout_err)
      result_osw[:eplusout_err].gsub!(/YMD=.*?,/, '')
      result_osw[:eplusout_err].gsub!(/Elapsed Time=.*?\n/, '')
      # Replace eplusout_err by a list of lines instead of a big string
      # Will make git diffing easier
      result_osw[:eplusout_err] = result_osw[:eplusout_err].split("\n")
    end

    result_osw.delete(:completed_at)
    result_osw.delete(:hash)
    result_osw.delete(:started_at)
    result_osw.delete(:updated_at)

    # Should always be true
    if (result_osw[:steps].size == 1) && (result_osw[:steps].select{|s| s[:measure_dir_name] == 'openstudio_results'}.size == 1)
      # If something went wrong, there wouldn't be results
      if result_osw[:steps][0].keys.include?(:result)
        result_osw[:steps][0][:result].delete(:completed_at)
        result_osw[:steps][0][:result].delete(:started_at)
        result_osw[:steps][0][:result].delete(:step_files)

        # Round all numbers to 2 digits to avoid excessive diffs
        # result_osw[:steps][0][:result][:step_values].each_with_index do |h, i|
        result_osw[:steps][0][:result][:step_values].each_with_index do |h, i|
          if h[:value].is_a? Float
            result_osw[:steps][0][:result][:step_values][i][:value] = h[:value].round(2)
          end
        end
      end
    end


    # The fuel cell tests produce out.osw files that are about 800 MB
    # because E+ throws a warning in the Regula Falsi routine (an E+ bug)
    # which results in about 7.5 Million times the same warning
    # So if the file size is bigger than 100 KiB, we throw out the eplusout_err
    if File.size(out_osw) > 100000
      result_osw.delete(:eplusout_err)
    end

    File.open(cp_out_osw,"w") do |f|
      f.write(JSON.pretty_generate(result_osw))
    end

    if $Save_idf
      in_idf = File.join(dir, 'run/in.idf')
      if File.exists?(in_idf)
        cp_in_idf = File.join($OutOSWDir, "#{filename}_#{$SdkVersion}_out#{$Custom_tag}.idf")
        FileUtils.cp(in_idf, cp_in_idf)
      end
    end

  end

  # standard checks
  assert_equal("Success", result_osw[:completed_status])

  return result_osw

end

# run a simulation test
# @param filename [String]: the filename to run, will be located and copied
# @param options [Hash]: can specify the following values:
#   * :outdir [String]: another level
#   * :base_dir [String]: where to look for filename to copy it (OSM) or run it
#   (RB), defaults to $ModelDir
def sim_test(filename, options = {})

  dir = File.join($TestDir, filename)
  if options[:outdir]
    dir = File.join($TestDir, options[:outdir])
  end
  if options[:base_dir]
    base_dir = options[:base_dir]
    puts "Setting base_dir to #{base_dir}"
  else
    base_dir = $ModelDir
  end

  puts "Running sim_test(#{filename})"

  in_osw = File.join(dir, 'in.osw')
  out_osw = File.join(dir, 'out.osw')
  in_osm = File.join(dir, 'in.osm')
  # Cp to the OutOSW directory
  cp_out_osw = File.join($OutOSWDir, "#{filename}_#{$SdkVersion}_out#{$Custom_tag}.osw")

  # If $DoNotReRunIfSuccess is true, we check if the out_osw already exists
  # and whether it was successful already
  if $DoNotReRunIfSuccess
    if File.exists?(cp_out_osw)
      cp_result_osw = nil
      File.open(cp_out_osw, 'r') do |f|
        cp_result_osw = JSON::parse(f.read, :symbolize_names=>true)
      end
      if !cp_result_osw.nil?
        if cp_result_osw[:completed_status] == "Success"
          skip "Already ran with success"
        end
      end
    end
  end

  # todo, modify different weather file in osw

  # todo, add other measures to the workflow

  # Start by deleting the testruns/test_xxx directory and recreating it
  FileUtils.rm_rf(dir) if File.exists?(dir)
  FileUtils.mkdir_p(dir)

  ext = File.extname(filename)
  if (ext == '.osm') or (ext == '.xml')

    if (ext == '.xml')
      new_filename = filename.sub('.xml', '.osm')
      FileUtils.mv(File.join(base_dir, filename),
                   File.join(base_dir, new_filename))
      filename = new_filename
      puts "Filename is now #{filename}"

      # Need to add design days...
    end

    # Copy the generic OSW needed for sim
    FileUtils.cp($OswFile, in_osw)

    # Check that version of OSM is inferior or equal to the current
    # openstudio sdk used (only for docker...)
    ori_file_path = File.join(base_dir,filename)
    v = OpenStudio::IdfFile.loadVersionOnly(ori_file_path)
    if not v
      fail "Cannot find versionString in #{filename}"
    end
    model_version = v.get.str

    if Gem::Version.new(model_version) > Gem::Version.new($SdkVersion)
      # Skip instead of fail
      skip "Model version is newer than the SDK version used (#{model_version} versus #{$SdkVersion})"
    end

    # Copy OSM to testruns dir
    FileUtils.cp(ori_file_path, in_osm)



    # Specific case for schedule_file_osm
    if (filename == 'schedule_file.osm')
      # We need to manually copy the supporting schedule into
      # the testruns folder for the simulation to be able to find it
      sch_ori_path = File.join(File.dirname(__FILE__),
                               'model/simulationtests/lib/schedulefile.csv')
      sch_ori_path = File.realpath(sch_ori_path)

      if Gem::Version.new($SdkVersion) == Gem::Version.new("2.7.0")
        # in 2.7.0, it needs to be at the same level as the OSM
        sch_target_path  = File.join(dir, File.basename(sch_ori_path))
      else
        # Going forward, it's inside the files/ subdirectory
        # Have to make the directory first
        files_dir = File.join(dir, 'files/')
        FileUtils.mkdir_p(files_dir)
        sch_target_path  = File.join(files_dir, File.basename(sch_ori_path))
      end

      FileUtils.cp(sch_ori_path, sch_target_path)
    end

  elsif (ext == '.rb')

    # Copy the generic OSW file, needed to add design days in particular when
    # running the measure to generate the OSM, and then of course for the sim
    FileUtils.cp($OswFile, in_osw)

    # command to generate the initial osm
    command = "\"#{$OpenstudioCli}\" \"#{File.join(base_dir, filename)}\""
    run_command(command, dir, 3600)

    # tests used to write out.osm
    out_osm = File.join(dir, 'out.osm')
    if File.exists?(out_osm)
      # puts "moving #{out_osm} to #{in_osm}"
      FileUtils.mv(out_osm, in_osm)
    end

    FileUtils.cp($OswFile, in_osw)

  elsif (ext == '.osw')

    # make an empty osm
    model = OpenStudio::Model::Model.new
    model.save(in_osm, true)

    # Copy the specific osw
    FileUtils.cp(File.join(base_dir,filename), in_osw)

  end

  fail "Cannot find file #{in_osm}" if !File.exists?(in_osm)
  fail "Cannot find file #{in_osw}" if !File.exists?(in_osw)

  # extra options passed to cli
  extra_options = ""
  extra_options += "--verbose " if options[:verbose]
  extra_options += "--include #{options[:include]} " if options[:include]
  extra_options += "--gem_path #{options[:gem_path]} " if options[:gem_path]
  extra_options += "--gem_home #{options[:gem_home]} " if options[:gem_home]
  extra_options += "--bundle #{options[:bundle]} " if options[:bundle]
  extra_options += "--bundle_path #{options[:bundle_path]} " if options[:bundle_path]

  extra_run_options = ""
  extra_run_options += "--debug " if options[:debug]

  # command to run the in_osw
  command = "\"#{$OpenstudioCli}\" #{extra_options} run #{extra_run_options} -w \"#{in_osw}\""
  # puts "COMMAND:"
  # puts command

  run_command(command, dir, 3600)

  # Post-process the out_osw
  result_osw = postprocess_out_osw_and_copy(out_osw, cp_out_osw)

  # return result_osw for further checks
  return result_osw
end

def intersect_test(filename)

  dir = File.join($TestDir, 'intersections', filename)
  src_osm = File.join($IntersectDir, filename)
  in_osm = File.join(dir, 'in.osm')
  out_osm = File.join(dir, 'out.osm')
  rb_file = File.join(dir, 'intersect.rb')

  FileUtils.rm_rf(dir) if File.exists?(dir)
  FileUtils.mkdir_p(dir)

  erb_in = ''
  File.open($IntersectFile, 'r') do |file|
    erb_in = file.read
  end

  # configure template with variable values
  renderer = ERB.new(erb_in)
  erb_out = renderer.result(binding)

  File.open(rb_file, 'w') do |file|
    file.puts erb_out
  end

  command = "\"#{$OpenstudioCli}\" intersect.rb"
  run_command(command, dir, 360)
end

# test the autosizing methods
def autosizing_test(filename, weather_file = nil, model_measures = [], energyplus_measures = [], reporting_measures = [])
  dir = File.join($TestDir, filename)
  in_osw = File.join(dir, 'in.osw')
  out_osw = File.join(dir, 'out.osw')
  cp_out_osw = File.join($OutOSWDir, "#{filename}_#{$SdkVersion}_out#{$Custom_tag}.osw")
  in_osm = File.join(dir, 'in.osm')
  sql_path = File.join(dir, 'run', 'eplusout.sql')

  $OPENSTUDIO_LOG = OpenStudio::StringStreamLogSink.new
  $OPENSTUDIO_LOG.setLogLevel(OpenStudio::Debug)

  # Run the workflow
  run_sim = true
  if run_sim
    FileUtils.rm_rf(dir) if File.exists?(dir)
    FileUtils.mkdir_p(dir)
    FileUtils.cp($OswFile, in_osw)

    ext = File.extname(filename)
    if (ext == '.osm')
      FileUtils.cp(File.join($ModelDir,filename), in_osm)
    elsif (ext == '.rb')
      command = "\"#{$OpenstudioCli}\" \"#{File.join($ModelDir,filename)}\""
      run_command(command, dir, 3600)

      # tests used to write out.osm
      out_osm = File.join(dir, 'out.osm')
      if File.exists?(out_osm)
        # puts "moving #{out_osm} to #{in_osm}"
        FileUtils.mv(out_osm, in_osm)
      end

      fail "Cannot find file #{in_osm}" if !File.exists?(in_osm)
    end

    command = "\"#{$OpenstudioCli}\" run -w \"#{in_osw}\""
    #command = "\"#{$OpenstudioCli}\" run --debug -w \"#{in_osw}\""

    run_command(command, dir, 3600)
  end

  # DLM: this line fails on a clean repo if run_sim is false, why would you want run_sim to be false?
  # JM: because this is useful if you're just modifying the code below
  # (= the checks) after a successful first run as you don't have to wait
  # minutes for the simulation itself to rerun
  # fail "Cannot find file #{out_osw}" if !File.exists?(out_osw)

  result_osw = postprocess_out_osw_and_copy(out_osw, cp_out_osw)

  # Load the model
  versionTranslator = OpenStudio::OSVersion::VersionTranslator.new
  model = versionTranslator.loadModel(in_osm)
  if model.empty?
    assert(model.is_initialized, "Could not load the resulting model, #{in_osm}")
  end
  model = model.get

  # Load and attach the sql file to the model
  sql_path = OpenStudio::Path.new(sql_path)
  if OpenStudio.exists(sql_path)
    sql = OpenStudio::SqlFile.new(sql_path)
    # Check to make sure the sql file is readable,
    # which won't be true if EnergyPlus crashed during simulation.
    unless sql.connectionOpen
      OpenStudio.logFree(OpenStudio::Error, 'openstudio.model.Model', "The run failed, cannot create model.  Look at the eplusout.err file in #{File.dirname(sql_path.to_s)} to see the cause.")
      return false
    end
    # Attach the sql file from the run to the model
    model.setSqlFile(sql)
  else
    OpenStudio.logFree(OpenStudio::Error, 'openstudio.model.Model', "Results for the run couldn't be found here: #{sql_path}.")
    return false
  end

  # Assert that the sizing run succeeded
  assert_equal("Success", result_osw[:completed_status])

  # Skip testing all methods for some objects
  # Skip testing some methods for other objects
  obj_types_to_skip = {
    'OS:WaterHeater:Mixed' => 'all', # WH sizing object not wrapped
    'OS:WaterHeater:Stratified' => 'all', # WH sizing object not wrapped
    'OS:WaterHeater:HeatPump' => 'all', # WH sizing object not wrapped
    'OS:WaterHeater:HeatPump:PumpedCondenser' => 'all', # WH sizing object not wrapped
    'OS:Boiler:Steam' => 'all', # CoilHeatingSteam is not wrapped, cannot use steam boiler in OS
    'OS:ChillerHeaterPerformance:Electric:EIR' => 'all', # TODO Not in test model (central HP system)
    'OS:SolarCollector:FlatPlate:PhotovoltaicThermal' => 'all', # TODO Not in test model
    'OS:Chiller:Absorption' => [
      'autosizedDesignGeneratorFluidFlowRate' # Generator loop not supported by OS
    ],
    'OS:Chiller:Absorption:Indirect' => [
      'autosizedDesignGeneratorFluidFlowRate' # Generator loop not supported by OS
    ],
    'OS:AirConditioner:VariableRefrigerantFlow' => [
      'autosizedWaterCondenserVolumeFlowRate' # Water-cooled VRF not supported by OS
    ],
    'OS:CoolingTower:TwoSpeed' => [
      'autosizedLowSpeedNominalCapacity', # Method only works on cooling towers sized a certain way, which test model isn't using
      'autosizedFreeConvectionNominalCapacity' # Method only works on cooling towers sized a certain way, which test model isn't using
    ],
    'OS:ZoneHVAC:LowTemperatureRadiant:VariableFlow' => [
      'autosizedHeatingDesignCapacity', # No OS methods for this field
      'autosizedCoolingDesignCapacity' # No OS methods for this field
    ]
  }

  # Aliases for some OS onjects
  os_type_aliases = {
    'OS:Coil:Cooling:LowTemperatureRadiant:VariableFlow' => 'OS:Coil:Cooling:LowTempRadiant:VarFlow',
    'OS:Coil:Heating:LowTemperatureRadiant:VariableFlow' => 'OS:Coil:Heating:LowTempRadiant:VarFlow',
    'OS:ZoneHVAC:LowTemperatureRadiant:VariableFlow' => 'OS:ZoneHVAC:LowTempRadiant:VarFlow',
  }

  # List of objects and fields where the autosized output does
  # not exist in the E+ output, even under a different name.
  # These are things the E+ team should fix.
  missing_getters = {
    'OS:Coil:Heating:Water:Baseboard:Radiant' => [
      'autosizedHeatingDesignCapacity'
    ],
    'OS:AirLoopHVAC:Unitary:HeatPump:AirToAir' => [
      'autosizedSupplyAirFlowRateWhenNoCoolingorHeatingisNeeded'
    ],
    'OS:Coil:Heating:Water:Baseboard' => [
      'autosizedHeatingDesignCapacity'
    ],
    'OS:EvaporativeFluidCooler:TwoSpeed' => [
      'autosizedLowSpeedUserSpecifiedDesignCapacity',
      'autosizedLowSpeedStandardDesignCapacity'
    ],
    'OS:ZoneHVAC:IdealLoadsAirSystem' => [
      'autosizedMaximumSensibleHeatingCapacity',
      'autosizedMaximumTotalCoolingCapacity'
    ],
    'OS:ZoneHVAC:FourPipeFanCoil' => [
      'autosizedMinimumSupplyAirTemperatureinCoolingMode',
      'autosizedMaximumSupplyAirTemperatureinHeatingMode'
    ],
    'OS:ZoneHVAC:UnitHeater' => [
      'autosizedMaximumHotWaterFlowRate'
    ],
    'OS:FluidCooler:TwoSpeed' => [
      'autosizedLowSpeedStandardDesignCapacity',
      'autosizedLowSpeedUserSpecifiedDesignCapacity'
    ],
    'OS:ZoneHVAC:Baseboard:RadiantConvective:Water' => [
      'autosizedHeatingDesignCapacity' # OS method for child coil, but E+ is missing output
    ],
    'OS:ZoneHVAC:Baseboard:Convective:Water' => [
      'autosizedHeatingDesignCapacity' # OS method for child coil, but E+ is missing output
    ],
    'OS:ThermalStorage:ChilledWater:Stratified' => [
      'autosizedUseSideInletHeight',
      'autosizedSourceSideOutletHeight'
    ]

  }

  # List of objects and methods where the getter name does not
  # match the IDD field name because of IDD shift, capitalization, etc.
  getter_aliases = {
    'OS:AirTerminal:SingleDuct:VAV:Reheat' => {
      'autosizedMaximumHotWaterorSteamFlowRate' => 'autosizedMaximumHotWaterOrSteamFlowRate', # Capitalization of 'Or'
      'autosizedMaximumFlowperZoneFloorAreaDuringReheat' => 'autosizedMaximumFlowPerZoneFloorAreaDuringReheat', # Capitalization of 'Per'
    },
    'OS:HeatPump:WaterToWater:EquationFit:Heating' => {
      'autosizedReferenceHeatingCapacity' => 'autosizedRatedHeatingCapacity',
      'autosizedReferenceHeatingPowerConsumption' => 'autosizedRatedHeatingPowerConsumption',
    },
    'OS:HeatPump:WaterToWater:EquationFit:Cooling' => {
      'autosizedReferenceCoolingCapacity' => 'autosizedRatedCoolingCapacity',
      'autosizedReferenceCoolingPowerConsumption' => 'autosizedRatedCoolingPowerConsumption',
    }
  }

  # Search the IDD associated with this model
  # and assert that there is at least one of every object
  # that has autosized fields in the test model.
  obj_counts = {}
  not_wrapped = []
  missing_autosizedFoo = []
  failed_autosizedFoo = []
  succeeded_autosizedFoo = []
  model.iddFile.objects.each do |idd_obj_type|
    autosizable_field_names = []
    idd_obj_type.nonextensibleFields.each do |idd_field|
      if idd_field.properties.autosizable
        autosizable_field_names << idd_field.name
      end
    end

    # Get the OS type
    os_type = idd_obj_type.type.valueDescription

    # Check if this object type has a different name in OS
    os_type = os_type_aliases[os_type] if os_type_aliases[os_type]

    # Convert to IDD type
    type = os_type.gsub('OS:','').gsub(':','')

    # Skip objects with no autosizable fields
    next if autosizable_field_names.empty?

    # Skip certain object types entirely
    methods_to_skip = obj_types_to_skip[os_type]
    next if methods_to_skip == 'all'
    methods_to_skip = [] if methods_to_skip.nil?

    # Convert the type name into a getter for objects from model
    method_name = "get#{type}s"

    # Skip objects that are in the IDD but not wrapped
    unless model.respond_to? method_name
      not_wrapped << type
      next
    end

    # Get the total number count of the objects
    # Add the objects to a hash by object type
    objs = model.public_send(method_name)
    obj_counts[type] = objs.size
    next if objs.size == 0

    # Get the first instance of this object type in the model
    obj = objs.sort[0]

    # Special cases
    case type
    when 'SizingSystem' # Need to check an AirLoop with an OA system
      objs.sort.each do |o|
        obj = o if o.airLoopHVAC.name.get == 'Air Loop'
      end
    when 'SizingZone' # Need to check a zone sized w/ DOAS
      objs.sort.each do |o|
        obj = o if o.thermalZone.name.get == 'Story 5 North Perimeter Thermal Zone'
      end
    when 'AirLoopHVACUnitarySystem' # Need to check a unitary where no load flow is autosized
      objs.sort.each do |o|
        obj = o if o.name.get == 'Air Loop HVAC Unitary System 3'
    end
    end

    # Test all autosizedFoo methods on this instance
    autosizable_field_names.each do |auto_field|
      # Make the getter name from the IDD field
      getter_name = "autosized#{auto_field.gsub(/\W/,'').strip}"

      # Replace the getter name with known alias, if one exists
      obj_aliases = getter_aliases[os_type]
      if obj_aliases
        getter_name = obj_aliases[getter_name] unless obj_aliases[getter_name].nil?
      end

      # Don't test this getter if it is designated to be skipped
      next if methods_to_skip.include?(getter_name)

      # Don't test this getter if it is known to be missing from E+ output
      obj_missing_getters = missing_getters[os_type]
      if obj_missing_getters
        next if obj_missing_getters.include?(getter_name)
      end

      # Check if the autosizedFoo method has been implemented for this object
      unless obj.respond_to? getter_name
        missing_autosizedFoo << "#{getter_name} not a valid method for object of type #{type}"
        next
      end

      # Try the method on the object to ensure that the SQL query in C++ is correct
      val = obj.public_send(getter_name)
      if val.is_initialized
        succeeded_autosizedFoo << "#{getter_name} succeeded for #{obj.name} of type #{type}"
      else
        failed_autosizedFoo << "#{getter_name} failed for #{obj.name} of type #{type}"
      end

    end

  end

  puts "\n*** Autosizable Objects not Wrapped by OpenStudio ***"
  not_wrapped.each { |f| puts f }

  puts "\n*** Failures ***"
  failed_autosizedFoo.each { |f| puts f }

  puts "\n*** Methods that aren't implemented in C++ (but should be) ***"
  missing_autosizedFoo.each { |f| puts f }

  puts "\n*** Missing Objects ***"
  missing_objs = []
  obj_counts.each do |type, count|
    if count.zero?
      missing_objs << type
      puts "#{type} is missing from test model"
    end
  end

  # Assert that no autosizable objects are missing from the test model
  # so that if someone wraps a new object and doesn't add it to this file, the test will fail.
  assert_equal(0, missing_objs.size, "There are #{missing_objs.size} autosizable objects missing from the test model:\n#{missing_objs.join("\n")}.")

  # Assert that every autosizable field for every object has a corresponding method implemented
  assert_equal(0, missing_autosizedFoo.size, "#{missing_autosizedFoo.size} autosizedFoo methods not implemented in C++:\n#{missing_autosizedFoo.join("\n")}.")

  # Assert that every autosizable field's getter returns a value
  assert_equal(0, failed_autosizedFoo.size, "#{failed_autosizedFoo.size} autosizedFoo methods failed to return a value:\n#{failed_autosizedFoo.join("\n")}.")

  # Add a few more object types to skip testing for based on test file object inputs
  obj_types_to_skip['OS:EvaporativeFluidCooler:TwoSpeed'] = [
      'autosizedDesignWaterFlowRate', # Value only present for some fluid cooler sizing input methods in test file
    ]
  obj_types_to_skip['OS:Sizing:System'] = [
      'autosizedDesignOutdoorAirFlowRate', # Not all AirLoopHVACs in model have OA system, needed for this output to exist
    ]
  obj_types_to_skip['OS:AirLoopHVAC:UnitarySystem'] = [
      'autosizedNoLoadSupplyAirFlowRate', # Not all Unitarys in test model have this field autosized
    ]

  # Count the number of autosized fields in the model
  def autosized_fields(model, obj_types_to_skip, missing_getters)

    # Convert to IDF
    idf = OpenStudio::EnergyPlus::ForwardTranslator.new.translateModel(model).toIdfFile

    # Ensure that all fields are set to "Autosize" or "Autocalculate"
    fields_autosized = []
    autosize_aliases = ['AutoSize', 'Autocalculate', 'Autosize', 'autocalculate']
    idf.objects.sort.each do |obj|
      os_type = "OS:#{obj.iddObject.type.valueDescription}"

      # Skip certain object types entirely
      methods_to_skip = obj_types_to_skip[os_type]
      next if methods_to_skip == 'all'
      methods_to_skip = [] if methods_to_skip.nil?

      # Get the list of getters to skip because missing from E+
      fields_to_skip = missing_getters[os_type]
      fields_to_skip = [] if fields_to_skip.nil?

      for field_num in 0..obj.numFields
        field_name = obj.fieldComment(field_num, true).to_s.gsub('!-','').gsub(/{.*}/,'').gsub(' ', '').strip
        getter_name = "autosized#{field_name}"
        # Don't check fields whose getters aren't being tested
        next if methods_to_skip.include?(getter_name)
        # Don't check fields whose getters aren't working because of E+ defficiencies
        next if fields_to_skip.include?(getter_name)
        # Check the value of the field
        val = obj.getString(field_num).to_s
        if autosize_aliases.include?(val)
          fields_still_autosized << "field #{field_name} in #{obj.iddObject.type.valueDescription}"
        end
      end

      return fields_autosized
    end

    # return result_osw for further checks
    return result_osw
  end

  # Get the autosized fields before hard sizing
  autosized_fields_before_hard_size = autosized_fields(model, obj_types_to_skip, missing_getters)

  # Hard-size the entire model
  model.applySizingValues()

  # Get the autosized fields after hard sizing
  autosized_fields_after_hard_size = autosized_fields(model, obj_types_to_skip, missing_getters)

  # Auto-size the entire model
  model.autosize()

  # Get the autosized fields after hard sizing
  autosized_fields_after_auto_size = autosized_fields(model, obj_types_to_skip, missing_getters)

  puts "\n*** Fields that are still autosized after hard sizing (but should not be) ***"
  autosized_fields_after_hard_size.each { |f| puts f }

  # Assert that all fields were hard-sized appropriately
  assert_equal(0, autosized_fields_after_hard_size.size, "#{autosized_fields_after_hard_size.size} autosized fields should be hard-sized, but aren't:\n#{failed_autosizedFoo.join("\n")}.")

  # Assert that all fields were set back to autosized
  assert_equal(autosized_fields_before_hard_size.size, autosized_fields_after_auto_size.size, "The number of autosized fields before hard sizing and after autosizing don't match.")

end



# This globs all OSW tests to find all known versions to date
# and finds the previous one before the current SdkVersion uses to run the
# script. If SdkVersion isn't know, returns the last known one. If the
# SdkVersion is the oldest known to date, returns nil. If the SdkVersion is
# already know, returns the one just before.
#
# @return previousVersion [String] the string of the previous version if found,
# nil otherwise
def find_previous_version()

  thisVersion = Gem::Version.new($SdkVersion)

  # We parse the test/ folder for all osm tests
  out_files = Dir.glob(File.join($OutOSWDir, "*"));
  re_version = Regexp.new('.*\.osm_(\d\.\d\.\d)_out\.osw');
  version_strings = out_files.select{|f| f.match(re_version)}.map{|f| f.scan(re_version).first.last}.uniq;
  # We sort them by the actual version
  versions = version_strings.map{|v| Gem::Version.new(v)}.sort;

  if versions.include?(thisVersion)
    thisIndex = versions.index(thisVersion)
    if thisIndex > 0
      previousVersion = versions[thisIndex-1]
      return previousVersion
    else
      puts "Cannot find a previous version for #{$SdkVersion} as it's the oldest known"
      return nil
    end
  else
    lastVersion = versions.last
    if thisVersion > lastVersion
      return lastVersion
    else
      puts "Cannot find a previous version for #{$SdkVersion} as it's older than the oldest known"
      return nil
    end
  end
end


# Sanitizes a filename replaces any of '-+= ' with '_'
#
# @param filename [String] The filename to sanitize
# @return [String] Sanitized filename
def escapeName(filename)
  return filename.gsub('-','_')
                 .gsub('+','_')
                 .gsub(' ','_')
                 .gsub("=",'_')
end


# Add Chicago Design days to an OpenStudio Model
# Used to add DDays to a SddReverseTranslated (from XML) OSM
#
# @param path [OpenStudio::Model::Model] the model to add the ddy to
# @return model [OpenStudio::Model::Model].
def add_design_days(model)

  ddy_path = OpenStudio::Path.new(File.join($RootDir, 'weatherdata/USA_IL_Chicago-OHare.Intl.AP.725300_TMY3.ddy'))

  ddy_idf = OpenStudio::IdfFile::load(ddy_path, "EnergyPlus".to_IddFileType).get
  ddy_workspace = OpenStudio::Workspace.new(ddy_idf)
  reverse_translator = OpenStudio::EnergyPlus::ReverseTranslator.new()
  ddy_model = reverse_translator.translateWorkspace(ddy_workspace)

  # Try to limit to the two main design days
  ddy_objects = ddy_model.getDesignDays().select { |d| d.name.get.include?('.4% Condns DB') || d.name.get.include?('99.6% Condns DB') }
  # Otherwise, get all .4% and 99.6%
  if ddy_objects.size < 2
    ddy_objects = ddy_model.getDesignDays().select { |d| d.name.get.include?('.4%') || d.name.get.include?('99.6%') }
  end
  #add the objects in the ddy file to the model
  model.addObjects(ddy_objects)


  # Do a couple more things
  sc = model.getSimulationControl
  sc.setRunSimulationforSizingPeriods(false)
  sc.setRunSimulationforWeatherFileRunPeriods(true)

  timestep = model.getTimestep
  timestep.setNumberOfTimestepsPerHour(4)

  return model

end
